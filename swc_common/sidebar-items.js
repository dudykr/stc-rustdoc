window.SIDEBAR_ITEMS = {"attr":[["ast_node","Alias for `#[derive(Spanned, Fold, Clone, Debug, PartialEq)]` for a struct and `#[derive(Spanned, Fold, Clone, Debug, PartialEq, FromVariant)]` for an enum."],["ast_serde","Derives `serde::Serialize` and `serde::Deserialize`."]],"constant":[["DUMMY_SP","Dummy span, both position and length are zero, syntax context is zero as well."],["NO_EXPANSION",""]],"derive":[["DeserializeEnum","Derives `serde::Deserialize` which is aware of `tag` based deserialization."],["EqIgnoreSpan","Derives `swc_common::EqIgnoreSpan`."],["FromVariant","Derives [`From`] for all variants. This only supports an enum where every variant has a single field."],["Spanned","Derives [`swc_common::Spanned`]. See [`swc_common::Spanned`] for documentation."],["TypeEq","Derives `swc_common::TypeEq`."]],"enum":[["FileName",""],["SpanLinesError",""],["SpanSnippetError",""]],"macro":[["add_bitflags","rustfmt-friendly version of `bitflags!`."],["chain","Chains multiple visitor."],["impl_stable_hash_via_hash",""]],"mod":[["collections",""],["comments",""],["errors",""],["hygiene","Machinery for hygienic macros, inspired by the `MTWT[1]` paper."],["input",""],["iter",""],["macros",""],["pass","This module reexports items from `swc_visit` with some swc-specific traits."],["plugin",""],["serializer",""],["source_map","The SourceMap tracks all the source code used within a single crate, mapping from integer byte positions to the original source code location. Each bit of source parsed during crate parsing (typically files, in-memory strings, or various bits of macro expansion) cover a continuous range of bytes in the SourceMap and are represented by SourceFiles. Byte positions are stored in `spans` and used pervasively in the compiler. They are absolute positions within the SourceMap, which upon request can be converted to line and column information, source code snippets, etc."],["sync","This module defines types which are thread safe if `cfg!(feature = \"concurrent\")` is true."],["util",""]],"static":[["GLOBALS","Storage for span hygiene data."]],"struct":[["BytePos","A byte offset. Keep this small (currently 32-bits), as AST contains a lot of them."],["CharPos","A character offset. Because of multibyte utf8 characters, a byte offset is not equivalent to a character offset. The SourceMap will convert BytePos values to CharPos values as necessary."],["FileLines","Note: This struct intentionally does not implement rkyv’s archieve to avoid redundant data copy (https://github.com/swc-project/swc/issues/5471) source_map_proxy constructs plugin-side Loc instead with shared SourceFile instance."],["Globals",""],["LineCol","Used to create a `.map` file."],["Loc","A source code location used for error reporting Note: This struct intentionally does not implement rkyv’s archieve to avoid redundant data copy (https://github.com/swc-project/swc/issues/5471) source_map_proxy constructs plugin-side Loc instead with shared SourceFile instance."],["LocWithOpt","A source code location used as the result of `lookup_char_pos_adj`"],["Mark","A mark is a unique id associated with a macro expansion."],["MultiSpan","A collection of spans. Spans have two orthogonal attributes:"],["SourceFile","A single source in the SourceMap."],["SourceFileAndBytePos",""],["SourceFileAndLine",""],["Span","Spans represent a region of code, used for error reporting. Positions in spans are absolute positions from the beginning of the `source_map`, not positions relative to `SourceFile`s. Methods on the `SourceMap` can be used to relate spans back to the original source. You must be careful if the span crosses more than one file - you will not be able to use many of the functions on spans in `source_map` and you cannot assume that the length of the `span = hi - lo`; there may be space in the `BytePos` range between files."],["SyntaxContext","A SyntaxContext represents a chain of macro expansions (represented by marks)."]],"trait":[["AstNode","A trait for ast nodes."],["EqIgnoreSpan","Derive with `#[derive(EqIgnoreSpan)]`."],["Spanned","Derive"],["TypeEq","Derive with `#[derive(TypeEq)]`."]]};